\documentclass{article}
\usepackage{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noEnd=false]{algpseudocodex}

\newtheorem{definition}{Définition}
\newtheorem{proposition}{Proposition}
\newtheorem{proof}{Preuve}

\title{INF8750: Projet de session \\ \large{Blindsort: le tri en aveugle}}
\author{Félix Larose-Gervais}

\pagestyle{headings}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}

\subsection{Contexte}

Le chiffrement homomorphe est un outils important dans la construction de Privacy Enhancing Technologies (PETs). Il permet de chiffrer des données de manière à ce qu'elles puissent être utilisées dans un calcul par une tierce partie sans avoir à être déchiffrées au préalable.

Peu après la publication du cryptosystème RSA~\cite{rivest_method_1978}, ses autheurs ont remarqué que le système était partiellement homomorphe~\cite{Rivest1978}. Ils se sont ensuite demandé s'il était possible de construire un schéma complètement homomorphe.

\begin{definition}
    Une fonction $\varphi : \mathbb{G} \to \mathbb{H}$ est appelé un \textbf{homomorphisme} si $\forall x, y \in \mathbb{G}$ on a:
    \[ \varphi(xy) = \varphi(x)\varphi(y)\]
\end{definition}

\begin{definition}
    On parle de \textbf{chiffrement homomorphe} lorsqu'un schéma $\Pi = (Gen, Enc, Dec)$ a pour propriété que son algorithme de chiffrement $Enc$ est un homomorphisme (modulo Dec).
\end{definition}

\begin{definition}
    Un schéma est dit \textbf{partiellement homomorphe} s'il permet l'évaluation de certains calculs sur ses cryptogrammes sans avoir à les déchiffrer.
\end{definition}

Par exemple, le schéma $RSA = (Gen, Enc, Dec)$ est partiellement homomorphe.
\begin{align*}
    RSA = \begin{cases}
        Gen(1^n) &:= (N, e, d) \gets GenRSA \\
        Enc_{N, e}(m) &:= m^e \mod N \\
        Dec_d(c) &:= c^d \mod N
    \end{cases}
\end{align*}

Où $GenRSA$ choisi aléatoirement $p, q$ deux grands nombres premiers et calcule $N = pq$ et $e, d \in \mathbb{Z}_N$ tels que $ed \equiv 1 \pmod N$. On dit que $(N, e)$ forme la clé publique et $(N, d)$ la clé privée.

En effet, soient $m_1, m_2 \in \mathbb{Z}_N$, tels que $c_1 = Enc_{N, e}(m_1)$ et $c_2 = Enc_{N, e}(m_2)$, on a:
\begin{align*}
    Enc_{N, e}(m_1m_2) 
        &\equiv {(m_1m_2)}^e \pmod N \\
        &\equiv m_1^e m_2^e \pmod N \\
        &\equiv Enc_{N, e}(m_1)Enc_{N, e}(m_2)
\end{align*}

On constate que l'on peut faire faire des multiplications de cryptogrammes RSA à une tierce partie, et en déchiffrer plus tard le résultat correct. D'autres cryptosystème ont été découverts partiellement homomorphes, tels que~\cite{elgamal1985public},~\cite{benaloh1994dense} et~\cite{paillier1999}.

\begin{definition}
    Un schéma est dit \textbf{complètement homomorphe} s'il permet l'évaluation de tout calcul sur ses cryptogrammes sans avoir à les déchiffrer.
\end{definition}

L'existence de schéma de chiffrement complètement homomorphe est resté une question ouverte pendant 30 ans.~\cite{gentry_fully_2009} a montré que c'était possible, en présentant le premier schéma complètement homomorphe, et a présenté une idée nouvelle, le bootstrapping, qui permet d'adapter certains schéma partiellement homomorphes pour les rendre complètement homomorphes.

Suite aux travaux de Gentry, plusieurs schémas de chiffrement complètement homomorphe ont vu le jour, notament TFHE~\cite{chillotti_tfhe_2020}, implémenté dans librairie TFHE-rs~\cite{TFHE-rs}. Par dessus cette librairie, le projet RevoLUT~\cite{RevoLUT} introduit de nouvelles primitives de rotation et permutation aveugle, celles-ci ont servi à la mise en place de Oblivious Turing Machine~\cite{azogagh_oblivious_2023}.

\newpage

\subsection{Objectif du projet}

Bien que le chiffrement homomorphe aie beaucoup évolué depuis sa conception, les schémas proposés aujourd'hui sont encore très inefficaces. Le but de ce projet est d'implémenter quelques algorithmes de tri en aveugle (c'est-à-dire opérant sur des données chiffrées) et de comparer leur performance entre eux et l'état de l'art.

Les deux premiers algorithmes implémentés sont basés sur le Direct Sort de~\cite{lauter_depth_2015}, l'un utilisant les primitives de Blind Matrix Access et de Blind Permutation offertes par RevoLUT, puis un autre utilisant directement les primitives de TFHE-rs. Ensuite, on présente une technique nouvelle basée sur deux passes de Blind Permutation de RevoLUT.\@

\subsection{Schéma TFHE}

Le schéma de chiffrement homomorphe TFHE est basé sur le problème de l'apprentissage avec erreur (Learning With Errors, LWE). La sécurité du schéma est basée sur la difficulté du problème de recherche de plus court vecteur dans les réseaux Euclidiens~\cite{regev_lattices_2009}.
\begin{align*}
    LWE = \begin{cases}
        Gen(1^n) &:= s \overset{R}{\gets} {\{0, 1\}}^n \\
        Enc_s(m) &:= (a, \sum{a_i s_i} + \Delta m + e),\, a \overset{R}{\gets} \mathbb{Z}_q^n, e \overset{R}{\gets} \chi_\sigma \\
        Dec_s(a, b) &:= (b - \sum{a_i s_i})  / \Delta
    \end{cases}
\end{align*}

Où $p, q$ des puissances de 2 sont les tailles de l'espace des messages et des cryptogrammes respectivement, tel que $\Delta = q / p$, avec $\Delta$ la taille réservée au bruit. Le bruit $e$ est tiré d'une distribution Gaussienne centrée de variance $\sigma$. On a donc $Enc_s : \mathbb{Z}_p \to \mathbb{Z}_q^n \times \mathbb{Z}_q$. On peut vérifier que le schéma $LWE$ est additivement homomorphe.
\begin{align*}
    Enc_s(m_1) + Enc_s(m_2) & = (a_1, a_1 \cdot s + \Delta m_1 + e_1) + (a_2, a_2 \cdot s + \Delta m_2 + e_2) \\
    &= (a_1 + a_2, (a_1 + a_2) \cdot s + \Delta (m_1 + m_2) + (e_1 + e_2)) \\
    &= Enc_s(m_1 + m_2)
\end{align*}

Similairement, on peut chiffrer des tableaux de taille $N$ (une puissance de 2) en les encodant comme des éléments de $\mathcal{R}_q = \mathbb{Z}_q[X]/(X^N+1)$, c'est-à-dire des polynômes à coefficients entiers (modulo $q$) de degré au plus $N - 1$.
\begin{align*}
    RLWE = \begin{cases}
        Gen(1^n) &:= S \overset{R}{\gets} \mathcal{R}_2 \\
        Enc_s(M) &:= (A, AS + \Delta M + E),\, A \overset{R}{\gets} \mathcal{R}_q, E \overset{R}{\gets} \chi_\sigma \\
        Dec_s(A, B) &:= (B - AS) / \Delta
    \end{cases}
\end{align*}

Il est important de mentionner que les opérations homomorphes sur les cryptogrammes (R)-LWE accumulent le bruit. Par conséquent, après un certains nombre d'opérations, le bruit déborde dans les bits de poids fort réservés au message, et rend le cryptogramme indéchiffrable. Afin de régler ce problème,~\cite{gentry_fully_2009} a proposé l'idée de bootstrapping; c'est-à-dire d'évaluer la procédure de déchiffrement en aveugle, à partir d'un chiffré de la clé et d'un chiffré du cryptogramme dont on veut réduire le bruit.

\cite{chillotti_tfhe_2020} ont proposé une amélioration à la procédure coûteuse de Gentry, basée sur la rotation aveugle de polynômes. Leur approche, en plus d'être plus rapide, permet l'évaluation de n'importe quelle fonction discrétisée $f$, en encodant les images de la fonction dans les coefficients d'un polynôme $P = \sum{f(i)X^i}$. L'évaluation aveugle de $f$ consiste donc en une rotation aveugle de $P$ suivie d'une extraction du premier coefficient.

\subsection{RevoLUT}

Le projet RevoLUT, basé sur TFHE-rs, expose une structure appelée une Look-Up Table (LUT). Cette structure est un tableau à taille fixe de messages chiffrés, sur lequel a été implémenté plusieurs nouvelles primitives tel que la rotation aveugle, la permutation aveugle et l'accès dans un tableau ou une matrice en aveugle.

\newpage

\section{Première implémentation}

\subsection{Direct Sort}

L'idée principale de l'algorithme est de construire une permutation à partir des comparaisons entre les paires d'éléments de la liste, puis de l'appliquer.

\begin{algorithm}
    \caption{Direct Sort dans RevoLUT}
    \begin{algorithmic}
        \Function{BlindSort}{T: LUT}
            \State{$\sigma \gets [0; n]$}
            \For{$i = 0$ to $n$}
                \For{$j = 0$ to $i$}
                    \State{$b \gets BMA(L, A[i], A[j])$}
                    \State{$\sigma[i] \gets \sigma[i] + b$}
                    \State{$\sigma[j] \gets \sigma[j] + 1 - b$}
                \EndFor{}
            \EndFor{}

            \Return{$BlindPermutation(A, \sigma)$}
        \EndFunction{}
    \end{algorithmic}
\end{algorithm}

La comparaison aveugle (LT) est implémentée grâce à la primitive Blind Matrix Access de RevoLUT.\@ On cherche dans la matrice binaire triangulaire inférieure stricte ($C$ telle que les entrées $C_{ij} = [i < j]$) en utilisant les deux valeurs à comparer comme indices.

\medskip

Par exemple, pour la LUT $A = [5, 4, 6, 3]$, on obtient:
\begin{align*}
    C = \begin{pmatrix}
        0 & 0 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        1 & 1 & 0 & 0 \\
        1 & 1 & 1 & 0
    \end{pmatrix} \qquad&\qquad
    L = \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        1 & 0 & 1 & 0 \\
        0 & 0 & 0 & 0 \\
        1 & 1 & 1 & 0
    \end{pmatrix}
\end{align*}

On observe que la somme des colonnes de $L$ forment la permutation $\sigma = (2, 1, 3, 0)$ qui, lorsque appliquée à $A$ donne la liste triée $\sigma(A) = [3, 4, 5, 6]$.

\subsection{Complexité}

Cette approche requiert $\frac{n^2-n}{2}$ comparaisons et une permutation, ce qui domine le temps d'exécution puisque chaque comparaison prends plus d'une seconde.

\section{Deuxième implémentation}

Cette deuxième méthode évite les comparaisons aveugles, au cout d'une permutation additionnelle.

\subsection{Algorithme}

L'idée est d'interpréter la liste donnée comme une permutation, que l'on applique à elle-même, ce qui produit une liste clairsemée mais relativement ordonnée. Ensuite, on construit et applique une seconde permutation compactant les entrées non-nulles.

\begin{algorithm}
    \caption{Permutation Sort}
    \begin{algorithmic}
        \Function{BlindSort}{A:\@ LUT}
            \State{$B \gets BlindPermutation(A, A)$}
            \State{$offset \gets 0$}
            \For{$i = 0$ to $n$}
                \State{$offset \gets offset + NULL(B[i])$}
                \State{$\sigma[i] \gets B[i] - offset$}
            \EndFor{}

            \Return{$BlindPermutation(B, \sigma)$}
        \EndFunction{}
    \end{algorithmic}
\end{algorithm}

La comparaison à zéro (NULL) est essentiellement un accès aveugle dans une LUT statique de la forme $[1, 0, \dots, 0]$.

Par exemple, pour $A = [5, 2, 7, 3, 0, 0, 0, 0]$, on peut la lire comme une permutation et l'appliquer à elle-même pour obtenir $B = [0, 0, 2, 3, 0, 5, 0, 7]$. Ensuite, on veut construire $\sigma = (4, 5, 0, 1, 6, 2, 7, 3)$ telle que $\sigma(B) = [2, 3, 5, 7, 0, 0, 0, 0]$.


\subsection{Complexité}

Cette deuxième approche ne requiert qu'un nombre linéaire en $n$ d'additions et de comparaisons scalaires, mais 2 permutations aveugles.

\section{Méthodologie}

\subsection{Property-based Testing}

À l'aide de la librairie QuickCheck, on peut comparer le comportement des nouvelles primitives aveugles avec leur contrepartie en clair sur des entrées arbitraires. Cela permet de s'assurer de leur exactitude pendant le développement.

\subsection{Micro-benchmarking}

Afin de comparer les temps d'exécution des différentes implémentations et de l'état de l'art, on utilisera la librairie Criterion pour établir des benchmarks avec statistiques et graphiques. En plus des travaux déjà mentionnés, on peut retrouver des résultats sur la performance du tri aveugle dans les articles de~\cite{baldimtsi_sorting_2014},~\cite{cryptoeprint:2011/122},~\cite{zuber2021efficient} et~\cite{choffrut_sable_2023}.

\newpage


\bibliography{refs}
\bibliographystyle{apalike-uqam}

\end{document}